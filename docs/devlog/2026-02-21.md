# 2026-02-21

## 18:20 — HLD §10 rename and PBEM/real-time hybrid play design

Two annotation blocks left in high-level-design.md during the initial review session were resolved today. Both were documentation-only changes with no code touched, but they had real design significance: one settled the scope of a whole tool category, and the other answered a fundamental question about how the multiplayer coordination model behaves across session boundaries.

The first change renamed §10 from "Developer Tools" to "Data Preparation Tools" and replaced the informal COMMENT with a structured four-bullet scope statement. The original label was too narrow — "developer tools" implies build tooling or debugging utilities, whereas the real purpose of this section is data accuracy: getting map terrain, unit statistics, scenario starting positions, and AI-generated datasets into a verified canonical form before any rules engine can rely on them. Broadening the intro now to name all four areas (map digitisation, unit data validation, scenario editing, AI data inspection) means future subsections each have a clearly defined home, and contributors reading the high-level design for the first time understand why non-trivial tooling is being invested in before a single line of game logic is written.

The second change addressed the PBEM/real-time switching question. The answer is that no switching mechanism is needed at all, because the architecture never had a "mode." Actions are always submitted via `POST /api/v1/games/:id/actions`; Socket.io is purely a notification channel that broadcasts state updates to whichever sockets happen to be in the game room at that moment. When both players are present the experience is real-time; when one disconnects the experience degrades naturally to async with Discord webhook notifications carrying the turn signal. The game state schema has no `mode` field and the server has no concept of play style. A session that starts live on a Saturday and migrates to weekday PBEM and back again requires zero user action and no server migration — it just works. This was captured as a "Hybrid Play" subsection immediately after the Real-Time Flow diagram in §5, where a reader comparing the two flow diagrams is most likely to ask exactly that question.

The one mechanical issue encountered was that Prettier reformatted the high-level design doc after the edits (trailing spaces and line-length adjustments in the new prose). Running `npx prettier --write` brought it back into compliance before the final format check passed. The pre-existing Vitest failures in the client test suites (missing `@vitejs/plugin-vue` configuration) were confirmed unchanged by stashing the edits and re-running the suite — same 6 failing suites, same 21 passing tests, before and after.

## 19:54 — Map Editor Detailed Design Specification

This session produced the map editor design document (`docs/map-editor-design.md`) that supersedes the gap analysis in `docs/high-level-design.md` §10. The plan was intentionally scoped to documentation only — no schema or code changes were made. The rationale is that a stable written spec provides a single reference point for the series of implementation plans that will follow, preventing the design from evolving ad-hoc across multiple coding sessions and ending up inconsistent.

The most significant architectural decision in the spec is the `edges` model for inter-hex features. Rather than assigning a canonical "owner" hex to each shared edge, the design calls for symmetric redundant storage: both hexes record the same `EdgeFeature[]` in their respective `edges` maps using mirrored directions. This trades a small amount of storage for a large reduction in implementation complexity — the engine can look up any hex's edges without needing to know which neighbour "owns" a given edge. The editor is responsible for keeping the two copies in sync on every write, which is a local invariant that is easy to enforce at the point of mutation.

The `HexDir` index (0=N, 1=NE, 2=SE, 3=S, 4=SW, 5=NW) is referenced in three independent sections of the spec: `slope` direction encoding (§1), wedge polygon geometry (§5), and slope arrow rotation arithmetic (§5). Keeping this mapping explicit in a reference table in §5 ensures all three uses stay consistent when the spec is read in isolation during implementation. The same index also drives `wedgeElevations[i]`, which stores elevation offsets per wedge rather than absolute values — this lets the base `elevation` field continue to serve as the primary LOS height while still allowing the engine to model sub-hex terrain relief where the physical map warrants it.

The three-tier save model (localStorage autosave → server save → engine export) formalises what was already partly present in the scaffolded editor but without a written spec describing the conflict resolution behaviour. The draft-restoration flow on load — comparing `_savedAt` timestamps and offering to restore or discard — was explicitly specified because it is exactly the kind of subtle UX detail that tends to be implemented inconsistently or omitted when a developer encounters it for the first time mid-feature. The engine export tier is marked lower priority since the server save (Tier 2) is what the game engine will actually consume; the export is a convenience for external tooling.

The high-level design §10 update removed the four gap descriptions (Gap 1–3) and the F1–F4 feature specifications that had been written during the scaffolding phase. Those were adequate as a quick planning note but were not the right level of detail for guiding implementation. They are now replaced by the architecture diagram showing all five components (including the three new ones: `EditorToolbar`, `WedgeEditor`, `EdgeEditPanel`) and a pointer to the design doc. The gap analysis is not lost — it is absorbed into §4 Interaction Modes and the component descriptions in §3, where the fixes are expressed as positive specifications rather than problem statements.

## 20:25 — PR: docs restructure, consistent naming, and map editor design spec

This PR delivers two independent but related workstreams that were batched together because both touched the same files. The first is a structural reorganisation of the `docs/` directory: source material (PDFs and images) is separated from project documents by moving it into `docs/reference/`, all file names are normalised to kebab-case (ending the mix of `SCREAMING_SNAKE`, `UPPER.md`, and `kebab-case.md`), and the devlog is converted from one-file-per-session to one-file-per-day with entries as `## HH:MM — Title` sections within each day file. The second workstream is the map editor detailed design spec (`docs/map-editor-design.md`), which supersedes the gap analysis that was previously inline in `high-level-design.md` §10.

The naming decisions follow a single rule: project Markdown documents use `kebab-case.md`, publisher source files in `docs/reference/` use `kebab-case` matching the document type (e.g. `lob-rules.pdf`, `sm-map.jpg`), and the two conventional uppercase files (`CLAUDE.md`, `README.md`) stay as they are. The devlog per-day consolidation removes the need for a slug in the filename — the date alone is sufficient to locate an entry, and the time+title heading inside the file provides the same context the slug previously carried in the filename. The index in `docs/devlog.md` is updated to one row per day, with the summary updated if multiple entries accumulate.

The map editor design spec (`docs/map-editor-design.md`) covers six sections: the revised `HexEntry` schema with `edges`, `slope`, `wedgeElevations`, and `features`; two `gridSpec` additions (`rotation`, `locked`); the five-component architecture with per-component scope; four interaction modes (select, paint, elevation, edge draw); six SVG visualization layers with geometry formulas; and a three-tier save model (localStorage autosave → server save → engine export). The symmetric redundant edge storage decision — both adjacent hexes store the same `EdgeFeature[]` in mirrored directions — is the most significant design choice and is documented with its rationale in §1.

All cross-references were updated: `CLAUDE.md`, `README.md`, `client/src/views/tools/MapEditorView.vue` (map image URL), `.claude/commands/wrap-plan.md`, and `.claude/commands/create-pr.md`. The `data/scenarios/` JSON files use old PDF names as internal source-citation annotations (`_source`, `_note` fields) and were intentionally left unchanged — those are historical provenance records, not file paths that the application resolves at runtime. No schema or application code changes were made in this PR.
